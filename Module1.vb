Option Explicit On
Option Compare Text

Module GetMethodAndTouch
#Const RunFromCommandLine = True
    Public Const Version_const = "1.0.0.6"
    Public Const Hand = -1  '= True
    Public Const Back = 0   '= False
    Public Const No_Of_Rows_Const = 6500
    Public Const No_Of_Bells_Const = 12
    Public Const MaxDings_const = 72012
    'Get overflow error if I try to declare maxdings as rows * bells...
    '72012 just in case there are 6001 rows...(during editing?)
    Public Const Offset_Const = 850 'offset to allow for early leading


    Public Const MethodPNLength_const = 200

    'constants for common dialog form
    Public Const cdlOFNHideReadOnly = &H4
    Public Const cdlOFNNoChangeDir = &H8
    Public Const cdlOFNExplorer = &H80000


    Public Structure BellTimeStructure
        Public bellch As Char
        Public Time As Long
    End Structure
    Public Structure GlbMethodRecord
        Public PNList() As String
        Public Name As String
    End Structure

    Public Structure GlbdispStructure
        Public xPos As Long
        Public ShbxPos As Long
        'shouldn't need long, but in case of sensor error...
    End Structure

    Private Structure RowError
        Public pos1 As Integer
        Public pos2 As Integer
    End Structure


    Public glbStartRow As Integer, glbEndRow As Integer, glbRow As Integer
    Public glbStatsEndRow As Integer, glbStatsStartRow As Integer
    Public glbThatsAllRow As Integer

    Public glbNo_Of_Bells As Byte, glbLastPlace As Byte

    Public glbNo_of_Bell_Events As Long   'total number of dongs
    'Generated by file load
    'Used in analyse to know
    'when end of data is reached

    Public glbLL As Integer, glbLHGenOp As String, glbPath2Libraries As String
    Public glbMethodName As String, glbStage As String
    Public glbCCCBR_PN As String, glbLeadHeadCode As String
    Public glbHLSym As Boolean, glbStartInRounds As Boolean
    Public glbBob1 As String, glbBob2 As String, glbBob As String
    Public glbSingle1 As String, glbSingle2 As String, glbSingle As String
    Public glbNormal1 As String, glbNormal2 As String, glbNormal As String
    Public glbStartChange As String, glbOther As String

    Public glbErrorThresh As Byte
    Public glbHandRatio As Single, glbAlpha As Single, glbBeta As Single
    Public glbAvHGap As Single, glbAvGap As Single, glbRMS As Single
    Public glbInputFile As String, glbOutputFile As String
    Public glbTouchScript As String, glbMethodFound As Boolean

    Public glbMethodPN(MethodPNLength_const) As String


    Public glbDingArray(MaxDings_const) As BellTimeStructure


    Public glbData(0 To No_Of_Rows_Const + 2, No_Of_Bells_Const) As BellTimeStructure
    'gives actual bell and time for row, position
    'need 2 extra rows for editing a max_rows file

    Public glbRowsArray(0 To No_Of_Rows_Const, No_Of_Bells_Const) As Char

    Public glbPNList(0 To No_Of_Rows_Const) As String

    Public glbDispData(0 To No_Of_Rows_Const, No_Of_Bells_Const) As GlbdispStructure
    'gives actual x location of bell at row, position and x location of where it
    'SHOULD be
    Public glbShbData(0 To No_Of_Rows_Const, No_Of_Bells_Const) As BellTimeStructure
    'gives bell and time that SHOULD be at row, position

    Sub Main()
        '***comment out lines here and in Detectmethod and GetPlaceNotation 
        'depending on whether running from IDE or command line
        On Error GoTo errorhandler
#If RunFromCommandLine Then
        Dim arguments() As String = Environment.GetCommandLineArgs() '***
        If UBound(arguments) < 2 Then '***
            'one or both command line arguments missing 
            Console.WriteLine(vbCrLf & "Version: " & Version_const) '***
            Exit Sub '***
        End If '***

        glbInputFile = arguments(1) '***
        glbOutputFile = arguments(2) '***
#Else

        glbOutputFile = "C:\Users\Martin\Documents\VS2019\MethodName.txt" '***
#End If
        Dim Filenum As Integer = FreeFile()

        FileOpen(Filenum, glbOutputFile, OpenMode.Output)
        FileClose(Filenum)

        'create empty glboutputfile - may be required to store any error messages

        glbAlpha = 0.4
        glbBeta = 0.1
        glbThatsAllRow = 0
#If Not RunFromCommandLine Then
        '***These are some test files that work OK
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\StedmanDoubles.crl"
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\YorkshireLittle12_20_06_17.crl"
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\PlainLittleTest.crl"
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\GrandsireTriples.crl"
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\PBMQuarterJH.crl"
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\Cambridege10_29_03_16.crl"
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\Grandsire9_29_03_16.crl"
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\Grandsire11_29_03_16.crl"
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\Kent12_29_03_16.crl"
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\Rounds8a_29_03_16.crl"
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\TrebleBob12_29_03_16.crl"
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\Doesnotexist.csv"
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\Bow.20150315-1810.s12t12.081216-001.bl.csv" '  (Stedman Cinques)
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\asdasdasd.csv" '  (Stedman Cinques)
        'glbInputFile = "C:\Users\Martin\Documents\VS2019\bishwalt.20100515-1524.s8t8.3hursley.bl.csv" '  (Grandsire Triples)
        'glbInputFile = "C:\Users\Martin\Documents\VS2019\barnes.20190312-1129.s8t8.Trial.bl.csv" ' (Bristol Major)
        'glbInputFile = "C:\Users\Martin\Documents\VS2019\asd.csv" '  (Rounds on 12)
        'glbInputFile = "C:\Users\Martin\Documents\VS2019\asdextra.csv" '  (Rounds on 14)
        'glbInputFile = "C:\Users\Martin\Documents\VS2019\badringing1.csv" '  (one lead of Cambridge Max. with method errors)
        'glbInputFile = "C:\Users\Martin\Documents\VS2019\badringing2.csv" '  (very bad plain hunt on 9)
        'glbInputFile = "C:\Users\Martin\Documents\vs2019\Exeter.20190622-1600.s12t12.9.bl.csv" '(Stedman Cinques)
        'glbInputFile = "C:\Users\Martin\Documents\VS2019\Walsall.20200308-1520.s12t12.8.0.bl.csv" ' (treble-bobbing)
        glbInputFile = "C:\Users\Martin\Documents\VS2019\peal1.csv" ' (Peal of Cambridge Max, treble backstroke snap ending)
        'glbInputFile = "C:\Users\Martin\Documents\VS2019\t1.csv" ' (Lincolnshire Max, "Handstroke uplift")
        'glbInputFile = "C:\Users\Martin\Documents\VS2019\qweqweqwe.csv" ' (London no 3 spliced with little Max,)
#End If
        OpenHawkearCSV(glbInputFile)    '*** for Hawkear input files
        'OpenCirelFile(glbInputFile)    '*** for Cirel input files

        glbTouchScript = ""
        DetectMethod()  'tries to work out the method,
        'then saves method name and stage, or error message to global variables
        If glbMethodFound Then
            DiscoverTouch() 'tries to work out the touch
        End If
        'if successful saves touch script to glbTouchScript.
        'if unsuccessful indicates stage and start row to glbTouchScript
        SaveMethodAndTouch()  'saves global info to output text file
        Exit Sub

errorhandler:
        If Err.Number = 75 Or Err.Number = 76 Then
            Console.WriteLine(vbCrLf & "!!! Error creating output file  " & Err.Number & ": " & Err.Description)
            ' output file spec bad, e.g. missing from second parameter.
            Exit Sub
        Else
            ErrorLog("!!! " & Err.Number & ": " & Err.Description)
        End If





    End Sub
    Private Function Belvert(bellch As Char) As Byte
        'converts a bellch character to corresponding numerical value
        Select Case bellch
            Case "1" To "9"
                Belvert = Val(bellch)
            Case "0", "O"   'Lowndes files use O
                Belvert = 10
            Case "E", "e"   'Abel files use lower case
                Belvert = 11
            Case "T", "t"
                Belvert = 12
            Case ","       'can't remember exactly why this is needed  Place notation list?
                Belvert = 100
            Case Else
                Belvert = 0
        End Select
    End Function
    Private Sub SaveMethodAndTouch()
        'Writes glbmethodname and glbstage to the output text file
        'and then the touchscript on the next line.

        On Error GoTo errorhandler

        ErrorLog(glbMethodName & " " & glbStage)
        ErrorLog(glbTouchScript)
        'Note this isn't an error log, but same file is used for storing geniune output
        'as errors

        Exit Sub

errorhandler:
        ErrorLog("!!! Touch save error: " & Err.Number & ": " & Err.Description)

    End Sub
    Private Function UnBelvert(Bell As Object) As Char
        'converts a number into to corresponding bell character
        Select Case Bell
            Case 1 To 9
                UnBelvert = Format$(Bell)
            Case 10
                UnBelvert = "0"
            Case 11
                UnBelvert = "E"
            Case 12
                UnBelvert = "T"
            Case Else
                UnBelvert = "?"

        End Select
    End Function
    Public Sub CalcHG()
        'This facility calculates the average handstroke gap compared to the average
        'normal gap and sets the value of glbHandRatio accordingly
        'Starts from glbstatsstartrow and finishes at glbstatsendrow if mnuSJ running
        'otherwise runs from row 1 to last full backstroke

        'Some error checking
        'Ignores any random dongs at the end of a touch
        'uses data from glbdata array and updates glbAvHGap and glbAvGap values
        'Note glbAvGap is the average of all the gaps, taking into account
        'normalised handstroke gaps as well as the rest of the gaps
        'sets glbhandratio

        Dim No_of_Handstrokes As Integer, c As Integer, R As Integer
        Dim RowRange As Long, HRow As Integer
        Dim b As Byte
        Dim TotalHG As Long, TotalAll As Long
        Dim AverageGap As Single, AvHGap As Single
        Dim Good_Row As Boolean

        On Error GoTo errorhandler

        R = glbEndRow
        If R < 2 Then Exit Sub

        'first, check to see if touch ended nicely
        'Bad final rows will be ignored
        Do
            Good_Row = True
            For b = 1 To glbNo_Of_Bells
                If glbData(R, b).bellch = Chr(0) Then
                    Good_Row = False
                    Exit For
                End If
            Next
            R -= 1
        Loop Until Good_Row = True
        R += 1

        'next, check they didn't stand at backstroke, or non-standers.
        'this check removed since may legitimately get backstroke final row when editing
        'not sure of consequences!
        'Do ignore final odd rows but don't change the global end row variable: use a
        'local one for this sub
        If R Mod 2 = 1 Then R -= 1
        'glbEndRow = R


        RowRange = R

        TotalHG = 0
        'First calculate how many handstroke gaps there are
        No_of_Handstrokes = (RowRange / 2) - 1
        If No_of_Handstrokes < 1 Then
            'short touch! No handstroke gaps
            Exit Sub
        End If

        'Now add up all the handstroke gaps
        b = glbNo_Of_Bells
        For c = 1 To No_of_Handstrokes
            HRow = 1 + (2 * c)
            TotalHG = TotalHG + glbData(HRow, 1).Time - glbData(HRow - 1, b).Time
        Next
        'Now work out the overall time

        TotalAll = glbData(R, b).Time - glbData(1, 1).Time
        'Now work out average non-hand gap
        AverageGap = (TotalAll - TotalHG) / ((RowRange * b) - No_of_Handstrokes - 1)
        '= (total time from first to last ding less all the hanstroke gaps) /
        'divided by (number of blows, excluding handstroke leads and very first blow)

        'and average handstroke gap
        AvHGap = TotalHG / No_of_Handstrokes
        glbAvHGap = AvHGap

        'and now the ratio
        glbHandRatio = AvHGap / AverageGap
        If glbHandRatio > 2.5 Or glbHandRatio < 0.8 Then glbHandRatio = 2
        'calculation goes awry if sensor problem.

        glbAvGap = AverageGap

        Exit Sub

errorhandler:
        ErrorLog("!!! Error calculating handstroke gap: " & Err.Number & ": " & Err.Description)

    End Sub

    Private Function CalcRMSStriking() As Single
        'Calculates the RMS value of the striking errors
        Dim Total As Long, Temp As Long, R As Integer, S As Long, b As Byte
        On Error GoTo errorhandler


        R = glbStatsEndRow - glbStatsStartRow + 1

        If R < 2 Then Exit Function

        Total = 0
        S = 1
        For R = glbStatsStartRow To glbStatsEndRow
            For b = 1 To glbNo_Of_Bells
                Temp = glbDispData(R, b).xPos - glbDispData(R, b).ShbxPos
                Total += Temp ^ 2
                S += 1
            Next
        Next
        'calculate x ^ 2, sum, divide by n and take square root to get RMS
        CalcRMSStriking = Math.Sqrt(Total / (S - 1))

        Exit Function
errorhandler:
        CalcRMSStriking = -1
        'message to callers that there's a problem

    End Function
    Private Sub ClearData()
        Dim Row As Integer, Bell As Byte

        For Row = 0 To No_Of_Rows_Const
            glbPNList(Row) = ""
            For Bell = 1 To No_Of_Bells_Const
                glbData(Row, Bell).bellch = Chr(0)
                glbData(Row, Bell).Time = 0
                glbRowsArray(Row, Bell) = Chr(0)
            Next
        Next

        glbEndRow = 0

    End Sub
    Private Function DiscoverLL(start As Integer, no_of_ch_bells As Byte) As Integer
        'finds out when treble next leads a full, right lead
        'assumes this is the lead length
        'returns lead length, or 0 if lead length greater than 4 * no of ch bells
        'or less than 8
        Dim Count As Integer
        Count = 2
        Do
            Count += 1
            If Count > 4 * no_of_ch_bells Then
                DiscoverLL = 0
                Exit Function
            Else
                If glbData(start + Count, 1).bellch = "1" And
                   glbData(start + Count + 1, 1).bellch = "1" And
                   Count Mod 2 = 0 Then
                    DiscoverLL = Count + 2
                    Exit Do
                End If
            End If
        Loop

    End Function

    Public Sub GetPlaceNotation(MethodName As String, Stage As String)
        'This is a bit illogical, since we already have the PN.  Hangover from early
        'Cirel work flow.  Needs to be updated at some time. It works, though!
        'tries to find the method (e.g. 'Grandsire' or 'Cambridge Surprise') at the stage
        'specified by the calling routine in the relevant CCCBR<n>.txt file.
        'If successful sets up Checkmethod to True, copies the lead head order code
        'into glbLeadHeadCode (e.g. "a", "k1" "4z") (this is used to work out the
        'likely calls), and copies the place notation (a tab-separated list of PN's,
        'including LE) into glbCCCBR_PN.
        '***Don't think this is quite accurate.  z-type Leadhead codes are not given
        'in the CCCBR_methods.txt file***
        '(The sub PrepGenerateRows interprets these two values and sets up other
        'variables ready to generate rows of the method.)
        'If method cannot be found appropriate message is given and
        'Checkmethod is set to False



        Dim Filenum As Integer, n As Integer, m As Integer, i As Integer
        Dim Entry As String, Name As String, Path As String
        Dim CheckMethod As Boolean


        'look up PN from CCCBR<n>.txt library, set up glbCCCBR_PN & glbLeadHeadCode

        Filenum = FreeFile()
#If runfromcommandline Then
        '***comment out one of these two lines depending on whether running from IDE or command line 
          
        Path = Environment.CurrentDirectory & "\CCCBR_lib\CCCBR" & Stage & ".txt"
#Else
        Path = "C:\Users\Martin\Documents\VS2019\CCCBR_lib\CCCBR" & Stage & ".txt"
#End If

        CheckMethod = False
        FileOpen(Filenum, Path, OpenMode.Input)
        For n = 1 To 5
            LineInput(Filenum)
            'Line Input #Filenum, Entry  'read/discard 5 lines of header info
        Next

        Do Until EOF(Filenum)
            'Line Input #Filenum, Entry 'read next line
            Entry = LineInput(Filenum)
            m = InStr(1, Entry, Chr(9))
            n = InStr(m + 1, Entry, Chr(9))

            Name = Mid$(Entry, m + 1, n - m - 1)

            If Name Like MethodName Then
                'found the method
                CheckMethod = True

                For i = 1 To 8  'tab across to the symmetry info
                    m = n + 1
                    n = InStr(m, Entry, Chr(9))
                Next
                glbLeadHeadCode = Mid$(Entry, m, n - m) 'lead head order code

                glbCCCBR_PN = Right$(Entry, Len(Entry) - n)
                'rest of info is tab-separated place notation list
                Exit Do
            End If
        Loop


        FileClose(Filenum)
        If CheckMethod = False Then
            ErrorLog("!!! Cannot find " & MethodName & " in " & Path)
        End If




    End Sub

    Public Function GenerateRows(StartPos As Integer, Annotation As String)
        'generates rows of a method, using glbmethodPN
        'and glbLHGenOp variables, and generating glbRowsArray, a 2D array
        'of the characters "1" through "T".
        'Assumes there is at least one row already in the array.  It starts from
        'StartPos, generating every row from the previous one in accordance with the
        'glbMethodPN array, etc information.  If rounds comes up, further rows of
        'rounds are generated, and then the function exits,
        'otherwise two courses are generated.
        'GenerateRows starts from the start of the place notation

        Dim m As Integer, n As Integer, RowNo As Integer
        'n is used to access the elements of glbMethodPN array
        'm is general purpose
        'RowNo corresponds to the rows of the entire touch
        Dim Place As Integer
        'Place is used to identify which places are made
        Dim a As Byte
        Dim RowString As String, FirstRowStr As String
        Dim GenOp As String
        Dim Rounds As String
        Dim Character As Char

        On Error GoTo errorhandler
        RowNo = StartPos - 1
        FirstRowStr = ""
        Rounds = ""
        For m = 1 To glbNo_Of_Bells
            FirstRowStr &= glbRowsArray(RowNo, m)
            Rounds &= UnBelvert(m)
        Next


        For a = 1 To 2  'do it twice: two courses
            Do  'loop1 - one course
                n = 1   'n works through the glbmethodPN() array


                'now generate rows until we get to the lead end or rounds
                Do  'loop2 - one lead
                    GenOp = glbMethodPN(n)
                    n += 1
                    If GenOp = "" Then Exit Do  'reached the end of the method place notation
                    glbRow = RowNo
                    ExecutePN(GenOp)

                    'record genop in glbpnlist
                    glbPNList(RowNo) = GenOp
                    RowNo += 1           'update to new row just created
                    RowString = ""
                    For m = 1 To glbNo_Of_Bells
                        RowString &= glbRowsArray(RowNo, m)
                    Next

                    If RowString = Rounds And RowNo - glbStartRow > 3 Then
                        'allow rounds on start + 1 of treble bobbing
                        If glbMethodPN(n) = "" Then glbPNList(RowNo - 1) = glbPNList(RowNo - 1) & "L"
                        'need to append "L" to PN for this rounds row - see erin example
                        GoTo Finish
                    End If

                Loop  '2 exit from this inner loop when we fetch "" from the methodPN array
                'time for lead head change
                If glbLHGenOp = "." Then
                    RowNo -= 1 'to compensate for the increment a few lines down...
                    glbPNList(RowNo) = glbPNList(RowNo) & "L" 'to signify lead head generator
                    'do nothing
                Else
                    glbRow = RowNo
                    ExecutePN(glbLHGenOp)
                    glbPNList(RowNo) = glbLHGenOp & "L"
                End If

                RowNo += 1
                RowString = ""
                For m = 1 To glbNo_Of_Bells
                    RowString &= glbRowsArray(RowNo, m)
                Next

                If RowString = Rounds Then
                    GoTo Finish
                End If




            Loop Until RowString = FirstRowStr   'loop1
        Next a 'produce two (repeated) courses so that a touch that continues after
        'a home call, for instance, shows up for more than just one row


        glbPNList(StartPos - 1) = glbPNList(StartPos - 1) & Annotation
        'indicate method change or start
        Exit Function

Finish:
        'get here if rounds comes up during normal (i.e. not a call) row generation
        glbThatsAllRow = RowNo
        'may get here several times during touch analysis, but last time may be All
        '(variable also gets updated in ImplementCall)
        GenerateRounds(RowNo, 100)
        RowNo = RowNo + n - 1

        glbPNList(StartPos - 1) = glbPNList(StartPos - 1) & Annotation
        'indicate method change or start (yes this is needed here)

        Exit Function

errorhandler:
        ErrorLog("!!! GenerateRows Error: " & Err.Number & ": " & Err.Description)

    End Function

    Public Sub DiscoverTouch()
        'Attempts to work out where/what the calls are, assuming method has been set
        'returns True if successful
        Dim CallOption As Byte
        Dim lclStartRow As Integer, Inc As Integer, LEMinusRow As Integer
        Dim i As Integer, j As Integer
        Dim TwoElementCall As Boolean, StillPossProb As Boolean
        Dim InitialRMSError As Single, RMSErrorLead As Single
        Dim SavedRMSResults(8) As Single, BestResult As Single
        Dim Rounds As String, RowStr As String
        Dim NoOfRubbishLeads As Integer
        Dim CallPN As String, CallPN2 As String

        NoOfRubbishLeads = 0

        If InStr(glbSingle1, ",") = 0 Then
            'calls are single-element at LE + 1
            TwoElementCall = False
        Else
            TwoElementCall = True
            'might even be three-element, e.g. Scientific Triples!
        End If


        lclStartRow = glbStartRow
        glbStatsStartRow = 3    'ignore first two rows in case poor pull-off
        If glbMethodName = "Stedman" Then
            If glbLastPlace = 5 Then
                glbStatsEndRow = lclStartRow + 4
            Else
                glbStatsEndRow = lclStartRow + 1
            End If
            Inc = glbLL \ 2 '6
        ElseIf glbMethodName = "Cloisters" Then
            glbStatsEndRow = lclStartRow + 1
            Inc = glbLL '6
        ElseIf glbMethodName = "Erin" Then
            glbStatsEndRow = lclStartRow + glbLL - 1
            Inc = glbLL
            'don't worry about bob go erin
        ElseIf TwoElementCall Then
            glbStatsEndRow = lclStartRow + glbLL - 3
            Inc = glbLL
        Else
            glbStatsEndRow = lclStartRow + glbLL - 2
            Inc = glbLL
        End If
        'sample the ringing up to but excluding first possible call

        LEMinusRow = glbStatsEndRow

        'LEMinusrow is last row before a possible call

        InitialRMSError = CalcRMSStriking()
        'got an idea of band's striking ability during initial rounds and first lead
        Do
            'now see what happens over the lead end and next lead
            LEMinusRow += Inc
            glbStatsStartRow = LEMinusRow - Inc
            glbStatsEndRow = glbStatsStartRow + Inc
            If glbStatsEndRow > glbEndRow Then glbStatsEndRow = glbEndRow
            RMSErrorLead = CalcRMSStriking()

            If (RMSErrorLead = -1 Or RMSErrorLead / glbNo_Of_Bells > 133) Then
                '133 is a somewhat arbitrary value. Allows JH's QP of Bob Minor to be
                'analysed.  Need some sort of maximum  to flag hopeless floundering.
                'major problem
                'need to update touch script with whatever has been discovered so far
                CreateTouchScript()
                ErrorLog("!!! Calc RMS error at LE " & LEMinusRow)
                Exit Sub
            End If
            If RMSErrorLead <= 3 * InitialRMSError Then
                StillPossProb = False
                NoOfRubbishLeads = 0
                'carry on, plain lead
            Else
                'save this result but try to find out the call PN, work out what call
                'may have taken place, and try it.
                SavedRMSResults(1) = RMSErrorLead
                StillPossProb = True
            End If

            If StillPossProb Then
                'get call PN, work out call, try it.
                If TwoElementCall Then
                    CallPN = DiscoverPN(LEMinusRow - Inc + 1)
                    If (glbLastPlace Mod 2 = 1) And (glbNo_Of_Bells Mod 2 = 0) And
            CallPN <> "?" Then
                        'strip tenor behind part for odd-bell methods being rung
                        'on an even number of bells
                        CallPN = Left(CallPN, Len(CallPN) - 1)
                    End If

                    CallPN2 = DiscoverPN(LEMinusRow - Inc + 2)
                    If (glbLastPlace Mod 2 = 1) And (glbNo_Of_Bells Mod 2 = 0) And
            CallPN <> "?" Then
                        'strip tenor behind part for odd-bell methods being rung
                        'on an even number of bells
                        CallPN2 = Left(CallPN2, Len(CallPN2) - 1)
                    End If
                    If CallPN = "?" Or CallPN2 = "?" Then
                        CallPN = "?"
                    Else
                        CallPN = CallPN & "," & CallPN2
                    End If
                Else
                    CallPN = DiscoverPN(LEMinusRow - Inc + 1)
                    If (glbLastPlace Mod 2 = 1) And (glbNo_Of_Bells Mod 2 = 0) And
            CallPN <> "?" Then
                        'strip tenor behind part for odd-bell methods being rung
                        'on an even number of bells
                        CallPN = Left(CallPN, Len(CallPN) - 1)
                    End If

                End If
                'CallPN will be something like "14", "147", "3,123", "?"
                If CallPN <> "?" Then
                    'does the call correspond with something we recognise?
                    If CallPN = glbBob1 Or CallPN = glbBob2 Then
                        glbBob = CallPN
                    End If
                    If CallPN = glbSingle1 Or CallPN = glbSingle2 Then
                        glbBob = ""
                        glbSingle = CallPN
                    End If
                    If glbBob <> "" Or glbSingle <> "" Then
                        If TwoElementCall Then
                            ImplementCall(CallPN, "", LEMinusRow - Inc + 2)
                        Else
                            ImplementCall(CallPN, "", LEMinusRow - Inc + 1)
                        End If
                        glbStatsStartRow = LEMinusRow - Inc
                        glbStatsEndRow = LEMinusRow
                        If glbStatsEndRow > glbEndRow Then glbStatsEndRow = glbEndRow
                        RMSErrorLead = CalcRMSStriking()

                        If RMSErrorLead <= 3 * InitialRMSError Then
                            'sorted
                            StillPossProb = False
                            NoOfRubbishLeads = 0
                        End If
                    End If
                End If
            End If

            If StillPossProb Then
                'try a bob, a single, go again, etc, each time
                'saving result.  Go with best result even if >= 3 * initial error
                '(2) try a bob
                SavedRMSResults(2) = 0
                If glbBob1 <> "" Then
                    glbBob = glbBob1
                    'glbSingle = "" no need since glbbob string is tested first in ImplementCall

                    If TwoElementCall Then
                        ImplementCall(glbBob, "", LEMinusRow - Inc + 2)
                    Else
                        ImplementCall(glbBob, "", LEMinusRow - Inc + 1)
                    End If
                    glbStatsStartRow = LEMinusRow - Inc
                    glbStatsEndRow = LEMinusRow
                    If glbStatsEndRow > glbEndRow Then glbStatsEndRow = glbEndRow
                    RMSErrorLead = CalcRMSStriking()

                    If RMSErrorLead <= 3 * InitialRMSError Then
                        'sorted
                        StillPossProb = False
                        NoOfRubbishLeads = 0
                    Else
                        'save this result
                        SavedRMSResults(2) = RMSErrorLead
                        'stillpossprob still true
                    End If
                End If
            End If

            SavedRMSResults(3) = 0
            If StillPossProb And glbSingle1 <> "" Then
                'still a lot of errors (3rd) so check if inserting a single reduces them
                glbBob = ""
                glbSingle = glbSingle1
                If TwoElementCall Then
                    ImplementCall(glbSingle, "", LEMinusRow - Inc + 2)
                Else
                    ImplementCall(glbSingle, "", LEMinusRow - Inc + 1)
                End If
                glbStatsStartRow = LEMinusRow - Inc
                glbStatsEndRow = LEMinusRow
                If glbStatsEndRow > glbEndRow Then glbStatsEndRow = glbEndRow
                RMSErrorLead = CalcRMSStriking()

                If RMSErrorLead <= 3 * InitialRMSError Then
                    'sorted
                    StillPossProb = False
                    NoOfRubbishLeads = 0
                Else
                    SavedRMSResults(3) = RMSErrorLead
                    'stillpossprob still true
                End If
            End If

            SavedRMSResults(4) = 0
            If StillPossProb And glbSingle2 <> "" Then
                'still a lot of errors (4th) so check if inserting alt single reduces them
                glbBob = ""
                glbSingle = glbSingle2

                ImplementCall(glbSingle, "", LEMinusRow - Inc + 1)
                'don't need to worry about single- or double-element calls for alt single
                glbStatsStartRow = LEMinusRow - Inc
                glbStatsEndRow = LEMinusRow
                If glbStatsEndRow > glbEndRow Then glbStatsEndRow = glbEndRow
                RMSErrorLead = CalcRMSStriking()

                If RMSErrorLead <= 3 * InitialRMSError Then
                    'sorted
                    StillPossProb = False
                    NoOfRubbishLeads = 0
                Else
                    SavedRMSResults(4) = RMSErrorLead
                End If
            End If

            SavedRMSResults(5) = 0
            If StillPossProb And
              Not (glbMethodName = "Stedman" Or glbMethodName = "Erin" Or
              glbMethodName = "Cloisters") Then
                'still a lot of errors (5th) so check for Bob, then
                'go again (no check here for rounds coming up, though)
                If glbBob1 <> "" Then
                    glbBob = glbBob1
                    If TwoElementCall Then
                        ImplementCall(glbBob, "", LEMinusRow - Inc + 2)
                        ImplementCall("", "Go again", LEMinusRow - Inc + 3)
                    Else
                        ImplementCall(glbBob, "", LEMinusRow - Inc + 1)
                        ImplementCall("", "Go again", LEMinusRow - Inc + 2)
                    End If

                    glbStatsStartRow = LEMinusRow - Inc
                    glbStatsEndRow = LEMinusRow
                    If glbStatsEndRow > glbEndRow Then glbStatsEndRow = glbEndRow
                    RMSErrorLead = CalcRMSStriking()

                    If RMSErrorLead <= 3 * InitialRMSError Then
                        'sorted
                        StillPossProb = False
                        NoOfRubbishLeads = 0
                    Else
                        SavedRMSResults(5) = RMSErrorLead
                    End If
                End If
            End If

            SavedRMSResults(6) = 0
            If StillPossProb And glbSingle1 <> "" And
              Not (glbMethodName = "Stedman" Or glbMethodName = "Erin" Or
              glbMethodName = "Cloisters") Then
                'still a lot of errors (6th) so check for Single, go again
                '(no check for rounds here, though)
                glbBob = ""
                glbSingle = glbSingle1
                If TwoElementCall Then
                    ImplementCall(glbSingle, "", LEMinusRow - Inc + 2)
                    ImplementCall("", "Go again", LEMinusRow - Inc + 3)
                Else
                    ImplementCall(glbSingle, "", LEMinusRow - Inc + 1)
                    ImplementCall("", "Go again", LEMinusRow - Inc + 2)
                End If

                glbStatsStartRow = LEMinusRow - Inc
                glbStatsEndRow = glbStatsStartRow + Inc
                RMSErrorLead = CalcRMSStriking()

                If RMSErrorLead <= 3 * InitialRMSError Then
                    'sorted
                    StillPossProb = False
                    NoOfRubbishLeads = 0
                Else
                    SavedRMSResults(6) = RMSErrorLead
                End If
            End If

            SavedRMSResults(7) = 0
            If StillPossProb And glbBob2 <> "" Then
                'still a lot of errors (7th)
                'unrecogmised call, but maybe there was one, so check for
                'alternative Bob, if there is one
                glbBob = glbBob2
                ImplementCall(glbBob, "", LEMinusRow - Inc + 1)
                glbStatsStartRow = LEMinusRow - Inc
                glbStatsEndRow = LEMinusRow
                If glbStatsEndRow > glbEndRow Then glbStatsEndRow = glbEndRow
                RMSErrorLead = CalcRMSStriking()

                If RMSErrorLead <= 3 * InitialRMSError Then
                    'sorted
                    StillPossProb = False
                    NoOfRubbishLeads = 0
                Else
                    SavedRMSResults(7) = RMSErrorLead
                End If
            End If

            SavedRMSResults(8) = 0
            If StillPossProb And
              Not (glbMethodName = "Stedman" Or glbMethodName = "Erin" Or
              glbMethodName = "Cloisters") Then
                'still a lot of errors (8th)
                'maybe plain lead end then go again, straightaway
                glbBob = ""
                glbSingle = ""
                glbNormal = glbNormal1
                If TwoElementCall Then
                    ImplementCall(glbNormal, "", LEMinusRow - Inc + 2)
                    ImplementCall("", "Go again", LEMinusRow - Inc + 3)
                Else
                    ImplementCall(glbNormal, "", LEMinusRow - Inc + 1)
                    'CallDialog.cmbOther.Text = "Go again"
                    ImplementCall("", "Go again", LEMinusRow - Inc + 2)
                End If
                glbStatsStartRow = LEMinusRow - Inc
                glbStatsEndRow = LEMinusRow
                If glbStatsEndRow > glbEndRow Then glbStatsEndRow = glbEndRow
                RMSErrorLead = CalcRMSStriking()

                If RMSErrorLead <= 3 * InitialRMSError Then
                    'sorted
                    StillPossProb = False
                    NoOfRubbishLeads = 0
                Else
                    SavedRMSResults(8) = RMSErrorLead
                End If
            End If

            If StillPossProb Then
                'check which call gave best result, then implement that call
                BestResult = 800

                For i = 1 To 8
                    If SavedRMSResults(i) <> 0 And SavedRMSResults(i) < BestResult Then
                        BestResult = SavedRMSResults(i)
                        CallOption = i
                    End If
                Next

                Select Case CallOption
                    Case 1
                        'plain lead gave best result
                        glbBob = ""
                        glbSingle = ""
                        glbNormal = glbNormal1

                        If TwoElementCall Then
                            ImplementCall(glbNormal, "", LEMinusRow - Inc + 2)
                        Else
                            ImplementCall(glbNormal, "", LEMinusRow - Inc + 1)
                        End If

                    Case 2
                        'bob gave best results
                        glbBob = glbBob1
                        If TwoElementCall Then
                            ImplementCall(glbBob, "", LEMinusRow - Inc + 2)
                        Else
                            ImplementCall(glbBob, "", LEMinusRow - Inc + 1)
                        End If
                    Case 3
                        'single gave best results
                        glbBob = ""
                        glbSingle = glbSingle1
                        If TwoElementCall Then
                            ImplementCall(glbSingle, "", LEMinusRow - Inc + 2)
                        Else
                            ImplementCall(glbSingle, "", LEMinusRow - Inc + 1)
                        End If
                    Case 4
                        'alternative single (e.g. in Stedman Doubles) gave best results
                        'don't need to worry about single- or double-element calls for alt single
                        glbBob = ""
                        glbSingle = glbSingle2
                        ImplementCall(glbSingle, "", LEMinusRow - Inc + 1)
                    Case 5
                        'bob followed by go again gave best results
                        glbBob = glbBob1
                        If TwoElementCall Then
                            ImplementCall(glbBob, "", LEMinusRow - Inc + 2)
                            ImplementCall("", "Go again", LEMinusRow - Inc + 3)
                        Else
                            ImplementCall(glbBob, "", LEMinusRow - Inc + 1)
                            ImplementCall("", "Go again", LEMinusRow - Inc + 2)
                        End If
                    Case 6
                        'single followed by go again gave best results
                        glbBob = ""
                        glbSingle = glbSingle1
                        If TwoElementCall Then
                            ImplementCall(glbSingle, "", LEMinusRow - Inc + 2)
                            ImplementCall("", "Go again", LEMinusRow - Inc + 3)
                        Else
                            ImplementCall(glbSingle, "", LEMinusRow - Inc + 1)
                            ImplementCall("", "Go again", LEMinusRow - Inc + 2)
                        End If
                    Case 7
                        'alternative bob gave best results
                        glbBob = glbBob2
                        ImplementCall(glbBob, "", LEMinusRow - Inc + 1)

                    Case 8
                        'plain lead followed by go again gave best result
                        glbBob = ""
                        glbSingle = ""
                        glbNormal = glbNormal1
                        If TwoElementCall Then
                            ImplementCall(glbNormal, "", LEMinusRow - Inc + 2)
                        Else
                            ImplementCall(glbNormal, "", LEMinusRow - Inc + 1)
                        End If

                End Select
            End If

            If StillPossProb Then
                NoOfRubbishLeads += 1
                If NoOfRubbishLeads > 2 Then
                    ErrorLog("!!! Cannot follow the touch at LE " & LEMinusRow - Inc)
                    CreateTouchScript()
                    Exit Sub
                End If
                'we have found the best call that matches the ringing but still not good;
                'maybe conductor called rounds so look back over the last lead to check.
                Rounds = ""
                For j = 1 To glbNo_Of_Bells
                    Rounds &= UnBelvert(j)
                Next j

                For i = LEMinusRow - Inc To LEMinusRow
                    RowStr = ""
                    For j = 1 To glbNo_Of_Bells
                        RowStr &= glbData(i, j).bellch
                    Next j
                    If RowStr = Rounds Then
                        'CallDialog.cmbOther.Text = "Rounds!"
                        glbOther = "Rounds!"
                        ImplementCall("", "Rounds!", i)
                        Exit For
                    End If
                Next i
                'found rounds, but did they start the method again?
                If i < LEMinusRow + 1 Then
                    DiscoverStartRow(i)
                    lclStartRow = glbStartRow
                    If lclStartRow = 0 Then
                        'No!
                    Else
                        'assume same method as before
                        glbStartRow = Format$(lclStartRow)
                        glbOther = "Change Method"  'otherwise rounds
                        'assumed up to new
                        'start
                        glbRow = lclStartRow   'to clear the should-be array
                        CmdDoneMethodChoose_Click()

                        If glbMethodName = "Stedman" Or
                           glbMethodName = "Cloisters" Then
                            LEMinusRow = lclStartRow + 1
                        ElseIf TwoElementCall Then
                            LEMinusRow = lclStartRow + glbLL - 3
                        Else
                            LEMinusRow = lclStartRow + glbLL - 2
                        End If
                    End If
                End If
            End If
        Loop Until LEMinusRow >= glbEndRow
        glbStatsStartRow = 1    'other subs may need this (Cirel thing?)
        CreateTouchScript()
    End Sub
    Private Sub CreateTouchScript()
        Dim i As Integer, Code As String
        'creates the touch script:
        'read info from glbPNList() array to create glbTouchScript,
        'a csv file recording start row and row-positions of calls

        glbTouchScript = "Call, Row" & vbCrLf


        i = 0

        Do
            i += 1
            If i > glbEndRow Then Exit Do
            Code = Right$(glbPNList(i), 1)
            If Code = "B" Or Code = "S" Or Code = "M" Then
                glbTouchScript = glbTouchScript & Code & "," & i + 1 & vbCrLf
                'i + 1 for consistency with Cirel
                'gives row in which call has taken effect 
            End If
        Loop
        If glbThatsAllRow <> 0 Then _
          glbTouchScript = glbTouchScript & "E," & glbThatsAllRow


    End Sub

    Public Sub ErrorLog(Message As String)
        'Appends Message to glboutputfile
        'assumes glboutputfile exists (Sub Main creates an empty version.)
        Dim Filenum As Integer

        Filenum = FreeFile()

        FileOpen(Filenum, glbOutputFile, OpenMode.Append)
        'FileOpen(Filenum, "C:\Users\Martin\Documents\vs2019\MethodName.txt", OpenMode.Append)
        PrintLine(Filenum, Message)
        'WriteLine(Filenum, Message)
        FileClose(Filenum)
    End Sub

    Public Sub ExecutePN(ByVal PN As String)
        'generates one new row for the glbrowsarray array
        'requires full Place Notation e.g. "123478" to be passed to it
        'and uses global variable glbRow to know where to start
        'Assumes glbrowsarray has been erased from the relevant row onwards
        Dim Place As Byte, n As Byte

        If PN = "-" Then  'must be even bell method and all swaps
            For n = 1 To glbNo_Of_Bells - 1 Step 2
                glbRowsArray(glbRow + 1, n) = glbRowsArray(glbRow, n + 1)
                glbRowsArray(glbRow + 1, n + 1) = glbRowsArray(glbRow, n)
            Next
        Else              'places
            For n = 1 To Len(PN)
                Place = Belvert(Mid$(PN, n, 1))
                glbRowsArray(glbRow + 1, Place) = glbRowsArray(glbRow, Place)
            Next
            For n = 1 To glbNo_Of_Bells
                If glbRowsArray(glbRow + 1, n) = Chr(0) Then
                    glbRowsArray(glbRow + 1, n) = glbRowsArray(glbRow, n + 1)
                    glbRowsArray(glbRow + 1, n + 1) = glbRowsArray(glbRow, n)
                End If
            Next
        End If

    End Sub

    Public Sub GenerateRounds(StartPos As Integer, no_of_rows As Integer)
        'generates no_of_rows rows of rounds in glbrowsarray, starting at StartPos
        'updates glbrow at the end
        'used for initial rounds, for those at the end of a touch and if Rounds!
        'is called
        Dim n As Integer, m As Byte, Note As Char

        If StartPos > 1 Then
            Note = Right(glbPNList(StartPos - 1), 1)
            Select Case Note
                Case "L", "B", "S"  'don't overwrite PN's ending in L, B or S with R
                Case Else
                    glbPNList(StartPos - 1) = "R"
            End Select
        End If

        For n = StartPos To StartPos + no_of_rows - 1
            If n > glbEndRow Then Exit For
            For m = 1 To glbNo_Of_Bells
                glbRowsArray(n, m) = UnBelvert(m)
            Next
            glbPNList(n) = "R"
        Next
        'End If
        glbRow = n
    End Sub

    Public Sub GlbAnalyse()

        'Based on John Harrison's alpha beta method to calculate when a bell should
        'ring. It should ring at a time based on the latest guess of when it should
        'ring and when it actually did ring. These two times are mixed:
        '((1-alpha) x the guess) + alpha x actual time.
        'The guess of when it should ring is when the previous bell should have rung
        '+ previous guess of correct interval.
        'The guess of the correct interval is a time based on the
        'previous guess of the correct interval + interval between bell ringing
        'and when previous one rang:
        '((1-beta) x last guess of interval) + beta x (actual interval).
        'alpha thus tries to keep the guess 'in phase' with the actual ringing, while
        'beta tries to keep up with changes in ringing speed.
        'Exact values of alpha and beta open to debate!
        't[n] = (t[n-1] + dt[n-1])(1-alpha) + t[m].alpha
        'dt[n] = dt[n-1](1-beta) + (t[m]-t[m-1]).beta
        'n, n-1 = latest, previous guess of when bell should ring; m when it did
        't = time, dt = interval.
        'Note, JH gives t[n-1] in the formula for dt[n]
        'All timing in ms.  Display uses a scalewidth of 4000 for the entire picture
        'and 1ms = 1 scalewidth unit.
        'Actual width is 9135 twips and 1 twip is 1/1440 of an inch.  This means one
        'second = (1000 * 9135)/(4000 * 1440) = 1.585"
        'Horizontal scroll bar can alter the scale width.  Calculations above are for
        'default Hscroll setting of 4000

        'Input: glbdata timing data and, if relevant, glbrowsarray.
        'Output: glbdispdata display data and glbshbdata
        'All of these arrays are global things
        'glbno_of_bells byte global variable should already be set
        'Sets glbEndRow variable, enables scroll bars, shading check box, tools menu
        'It gets called by analyse tools menu, File open menu so that the cirel data
        'is analysed immediately after being recalled from disk.
        'Also called by cmbDoneMethodChoose when checking against actual method

        Dim P As Integer, q As Integer, No_of_Bell_Events As Long
        Dim j As Byte, i As Byte
        Dim shbTime1 As Long 'time when first bell in row should ring
        Dim Gap As Single 'Long 'dt[n], dt[n-1]
        Dim shbTime As Long 't[n],t[n-1]
        Dim CalTime As Long
        Dim Lead_error As Boolean
        Dim RowError As Boolean
        Dim xPos As Long, xPos1 As Long, Avg As Single, ShbxPos As Long
        Dim Row_number As Integer, HandGap As Long
        Dim Lead_Striking_Error As Long 'shouldn't ever get that big, but may do if
        'there is a sensor error
        Dim shbBell As Char

        On Error GoTo errorhandler

        CalcHG()  'calculate hand:gap ratio for touch


        'first clear the glbdispdata() array (in order to count errors later),
        'copy bell data to shbdata array, and clear all shbdata timing info
        For P = 1 To No_Of_Rows_Const
            For q = 1 To No_Of_Bells_Const
                With glbDispData(P, q)
                    .ShbxPos = 0
                    .xPos = 0
                End With
                With glbShbData(P, q)
                    .Time = 0
                    .bellch = glbData(P, q).bellch
                End With
            Next
        Next

        Row_number = 1
        No_of_Bell_Events = 0

        'recalibrate all timing data for 0 start time.
        'may be unnecessary since other analyses do this as well
        CalTime = glbData(1, 1).Time

        'glbno_of_bell_events is not set in Diagrams so we need the >= test

        Do
            For j = 1 To glbNo_Of_Bells
                glbData(Row_number, j).Time = glbData(Row_number, j).Time - CalTime
                No_of_Bell_Events += 1
                If No_of_Bell_Events >= glbNo_of_Bell_Events Then Exit Do
            Next
            Row_number += 1
        Loop

        If glbData(Row_number, 1).bellch = Chr(0) Then glbEndRow = Row_number - 1 _
                                                    Else glbEndRow = Row_number

        Lead_error = False
        If Not (((glbNo_Of_Bells) > 3) And ((glbNo_Of_Bells) < 13)) Then
            ErrorLog("!!! Cannot analyse this data: wrong format: Analysis error")
            Exit Sub
        End If


        xPos1 = Offset_Const
        glbDispData(1, 1).xPos = xPos1
        glbDispData(1, 1).ShbxPos = xPos1
        shbTime1 = glbData(1, 1).Time
        glbShbData(1, 1).Time = shbTime1
        glbShbData(1, 1).bellch = "1"

        Avg = (glbData(2, glbNo_Of_Bells).Time - glbData(1, 1).Time) / (2 * glbNo_Of_Bells - 1)
        'calculate average spacing of rows 1 & 2
        '(glbdata(1,1).time will be 0 for normal analyses but not for diagrams)

        HandGap = glbHandRatio * Avg

        'second blow...
        xPos = xPos1 + glbData(1, 2).Time - glbData(1, 1).Time
        glbDispData(1, 2).xPos = xPos
        glbDispData(1, 2).ShbxPos = xPos1 + Avg
        'assume bell 2 should ring at average spacing of first row after bell 1
        shbTime = glbData(1, 1).Time + Avg
        Gap = Avg
        ''correct' interval = average of first two rows
        ShbxPos = xPos1 + Avg
        glbShbData(1, 2).Time = shbTime
        glbShbData(1, 2).bellch = glbData(1, 2).bellch

        'now the rest of the first row...

        For j = 3 To glbNo_Of_Bells
            shbTime = (Math.Round((shbTime + Gap) * (1 - glbAlpha) +
                glbData(1, j).Time * glbAlpha))
            'latest estimate of 'correct' time to ring
            Gap = Math.Round(Gap * (1 - glbBeta) +
                       (glbData(1, j).Time - glbData(1, j - 1).Time) * glbBeta)
            'latest estimate of 'correct' interval

            glbShbData(1, j).Time = shbTime
            glbShbData(1, j).bellch = glbData(1, j).bellch
            ShbxPos = Offset_Const + (shbTime - shbTime1)
            'the point position showing where it should be
            'is calculated from where the first bell in row should be
            '+ 'correct' time interval between this bell and first

            xPos = xPos + glbData(1, j).Time - glbData(1, j - 1).Time
            'point position of where it did ring is calculated
            'from point position of where previous bell rang
            '+ actual interval
            glbDispData(1, j).xPos = xPos
            glbDispData(1, j).ShbxPos = ShbxPos
        Next

        'check that we pulled off in rounds...
        'If glbCheckMethod Then
        For P = 1 To glbNo_Of_Bells
            If glbData(1, P).bellch <> glbRowsArray(1, P) Then
                'RowError so sort out immediately
                'find out who should have rung at this position
                shbBell = glbRowsArray(1, P)
                'and place it in the correct position with corrected timing in shb array
                glbShbData(1, P).bellch = shbBell
                glbShbData(1, P).Time = (P - 1) * Avg
                'find out where it should have rung and update glbdispdata.shbxpos
                For i = 1 To glbNo_Of_Bells
                    If glbData(1, P).bellch = glbRowsArray(1, i) Then
                        glbDispData(1, P).ShbxPos = Offset_Const + (i - 1) * Avg
                        Exit For
                    End If
                Next
            End If
        Next
        'End If
        P = 1

        '...and now the rest of the rows...

        Row_number = 2
        RowError = False
        'check row is full
        For j = 1 To glbNo_Of_Bells
            If glbData(Row_number, j).bellch = Chr(0) Then Exit Sub
        Next
        Do                        'new row loop
            '    If Row_number Mod 2 = 0 Then k = 1 Else k = glbHandRatio  'back else hand
            'If glbCheckMethod Then
            If glbData(Row_number, 1).bellch <> glbRowsArray(Row_number, 1) Then
                RowError = True
            End If
            'End If
            If (glbData(Row_number, 1).Time <
                                  glbData(Row_number - 1, glbNo_Of_Bells).Time) Then
                'leading error: new estimate of interval ignores measured time.
                Lead_error = True

                If Row_number Mod 2 = 0 Then
                    shbTime += Gap  'backstroke
                Else
                    shbTime += HandGap    'handstroke
                End If
            Else
                'normal leading
                If Row_number Mod 2 = 0 Then  'backstroke
                    shbTime = Math.Round((shbTime + Gap) * (1 - glbAlpha) +
                              glbData(Row_number, 1).Time * glbAlpha)
                    Gap = Math.Round(Gap * (1 - glbBeta) +
                               (glbData(Row_number, 1).Time -
                                glbData(Row_number - 1, glbNo_Of_Bells).Time) * glbBeta)
                Else                          'handstroke
                    shbTime = Math.Round((shbTime + HandGap) * (1 - glbAlpha) +
                               glbData(Row_number, 1).Time * glbAlpha)
                    HandGap = Math.Round(HandGap * (1 - glbBeta) +
                               (glbData(Row_number, 1).Time -
                                glbData(Row_number - 1, glbNo_Of_Bells).Time) * glbBeta)
                End If
            End If
            shbTime1 = shbTime               'update shbtime1 to current row
            glbShbData(Row_number, 1).Time = shbTime

            Lead_Striking_Error = glbData(Row_number, 1).Time - shbTime1

            xPos1 = Offset_Const + Lead_Striking_Error

            glbDispData(Row_number, 1).xPos = xPos1
            glbDispData(Row_number, 1).ShbxPos = Offset_Const
            'now do the second bell
            If glbData(Row_number, 2).bellch = Chr(0) Then Exit Do
            'If glbCheckMethod Then
            If glbData(Row_number, 2).bellch <> glbRowsArray(Row_number, 2) Then
                RowError = True
            End If
            'End If
            If Lead_error Then
                shbTime += Gap
                Lead_error = False
            Else
                shbTime = Math.Round((shbTime + Gap) * (1 - glbAlpha) +
                          glbData(Row_number, 2).Time * glbAlpha)
                Gap = Math.Round(Gap * (1 - glbBeta) +
                  (glbData(Row_number, 2).Time - glbData(Row_number, 1).Time) * glbBeta)
            End If

            xPos = xPos1 + glbData(Row_number, 2).Time - glbData(Row_number, 1).Time
            ShbxPos = Offset_Const + (shbTime - shbTime1)
            glbDispData(Row_number, 2).xPos = xPos
            glbDispData(Row_number, 2).ShbxPos = ShbxPos

            glbShbData(Row_number, 2).Time = shbTime
            'and now do the rest of the row
            For j = 3 To glbNo_Of_Bells
                If glbData(Row_number, j).bellch = Chr(0) Then Exit Do
                'If glbCheckMethod Then
                If glbData(Row_number, j).bellch <> glbRowsArray(Row_number, j) Then
                    RowError = True
                End If
                'End If

                shbTime = Math.Round((shbTime + Gap) * (1 - glbAlpha) +
                          glbData(Row_number, j).Time * glbAlpha)
                Gap = Math.Round(Gap * (1 - glbBeta) +
                             (glbData(Row_number, j).Time -
                             glbData(Row_number, j - 1).Time) * glbBeta)

                xPos = xPos + glbData(Row_number, j).Time -
                              glbData(Row_number, j - 1).Time

                ShbxPos = Offset_Const + (shbTime - shbTime1)
                glbDispData(Row_number, j).xPos = xPos
                glbDispData(Row_number, j).ShbxPos = ShbxPos
                glbShbData(Row_number, j).Time = shbTime
            Next j
            'another row done


            If RowError Then
                'find a reasonable bell interval
                Avg = glbAvGap  'use the average gap of the whole touch
                'and use this to calculate where ALL the bells should have rung
                For P = 1 To glbNo_Of_Bells
                    'find out which bell should be at this position
                    shbBell = glbRowsArray(Row_number, P)
                    'and place it in the correct position with corrected timing in shb array
                    glbShbData(Row_number, P).bellch = shbBell
                    glbShbData(Row_number, P).Time = glbShbData(Row_number, 1).Time +
                                                                    (P - 1) * Avg

                    'find out where it should have rung and update glbdispdata.shbxpos
                    For i = 1 To glbNo_Of_Bells
                        If glbData(Row_number, P).bellch = glbRowsArray(Row_number, i) Then
                            glbDispData(Row_number, P).ShbxPos = Offset_Const + (i - 1) * Avg
                            Exit For
                        End If
                    Next
                Next
            End If

            RowError = False

            P = 1
            Row_number += 1

        Loop Until Row_number > glbEndRow

        Exit Sub
errorhandler:
        ErrorLog("!!! Analyse Error: " + Err.Number & ": " & Err.Description)

    End Sub

    Public Sub ImplementCall(ByVal CallGenOp As String, OtherOp As String, ByVal Row As Integer)
        'checks a valid call has been requested, including "Rounds!" etc,
        'then clears the global rows array from the row value passed to the sub,
        'then calls executepn to execute the PN(s) comprising the call'
        'then sets the code for the row ("L", "B", etc)
        Dim Rounds As String, RowString As String
        Dim GenOp(3) As String
        Dim Code As Char
        Dim invalidPN As Boolean, StedmanType As Boolean
        Dim NoOfGenOps As Byte
        Dim b As Byte, Bell As Byte, Pos As Byte, Place As Byte, LastPlace As Byte
        Dim RowNo As Integer, n As Integer, LHRow As Integer
        Dim R As Integer, interval As Integer
        Dim NomTime As Long
        Dim ReachedRounds As Boolean = False

        On Error GoTo errorhandler

        StedmanType = glbMethodName Like "stedman" Or
                      glbMethodName Like "erin" Or
                      glbMethodName Like "cloisters"

        Rounds = ""
        For b = 1 To glbNo_Of_Bells
            Rounds &= UnBelvert(b)
        Next
        LastPlace = glbLastPlace
        'check valid place notation
        invalidPN = False
        For b = 1 To Len(CallGenOp)
            Bell = Belvert(Mid$(CallGenOp, b, 1))
            If Bell = 0 Then invalidPN = True
        Next
        If CallGenOp = "" Then invalidPN = True
        If OtherOp <> "" Then invalidPN = False 'Rounds!, Go again or Change Method
        'Changing method should not be allowed to occur at any row, but not a big
        'issue, and a little awkward logic to sort out...
        If invalidPN Then
            ErrorLog("!!! No call selected, or invalid call")
            'do nothing
        ElseIf OtherOp = "Rounds!" Then
            GenerateRounds(Row, 30)  '30 rows of rounds (sub updates glbrow)
            ClearRAfrom(glbRow)
            invalidPN = True  'prevent rounds checking/row generation at end of sub
        ElseIf OtherOp = "Go again" Then
            glbStartRow = Row
            ClearRAfrom(Row)
            invalidPN = True  'prevent rounds checking/row generation at end of sub
            GenerateRows(Row, "M")
        ElseIf OtherOp = "Change Method" Then
            glbStartRow = Format$(Row)
            glbRow = Row
            Exit Sub

        Else
            If glbHLSym Or StedmanType Then
                RowNo = Row
            Else
                RowNo = Row - 1
            End If

            'first, clear the array from the affected row onwards
            ClearRAfrom(RowNo)
            If RowNo = 1 Then
                'probably diagrams, "bob, go erin" and 0th row of glbrowsarray needs
                'to have initial rounds set up
                For b = 1 To glbNo_Of_Bells
                    glbRowsArray(0, b) = UnBelvert(b)
                Next
            End If

            'go back to last intact row of glbrowsarray
            If glbHLSym Then
                If Not (StedmanType) Then
                    RowNo = Row - 1  'Plain Bob etc
                End If
            Else
                RowNo = Row - 2  'Grandsire etc
            End If
            '(further adjustments to rowno later for specials)

            If glbHLSym And Not (StedmanType) Then
                'just one gen op to execute
                If glbNo_Of_Bells = LastPlace + 1 Then  'add tenor behind
                    CallGenOp &= UnBelvert(glbNo_Of_Bells)
                End If
                glbRow = RowNo  'for benefit of executePN
                ExecutePN(CallGenOp)

                If glbBob <> "" Then
                    Code = "B"
                ElseIf glbSingle <> "" Then
                    Code = "S"
                ElseIf glbNormal <> "" Then
                    Code = "L"
                End If
                glbPNList(RowNo) = CallGenOp & Code
            ElseIf Not StedmanType Then
                'two genops to execute, e.g. "38,1238" for a single in Grandsire Major
                'generate the two gen ops
                Pos = 1
                GenOp(1) = ""
                Do Until Mid$(CallGenOp, Pos, 1) = ","
                    GenOp(1) = GenOp(1) & Mid$(CallGenOp, Pos, 1)
                    Pos += 1
                Loop
                If glbNo_Of_Bells = LastPlace + 1 Then  'add tenor behind
                    GenOp(1) = GenOp(1) & UnBelvert(glbNo_Of_Bells)
                End If

                Pos += 1 'skip the ","

                GenOp(2) = ""
                Do Until Pos > Len(CallGenOp)
                    GenOp(2) = GenOp(2) & Mid$(CallGenOp, Pos, 1)
                    Pos += 1
                Loop
                'add tenor behind if appropriate
                If glbNo_Of_Bells = LastPlace + 1 Then  'add tenor behind
                    GenOp(2) = GenOp(2) & UnBelvert(glbNo_Of_Bells)
                End If
                glbRow = RowNo
                ExecutePN(GenOp(1))
                glbPNList(RowNo) = GenOp(1)
                RowNo += 1
                glbRow = RowNo
                ExecutePN(GenOp(2))

                If glbBob <> "" Then
                    Code = "B"
                ElseIf glbSingle <> "" Then
                    Code = "S"
                ElseIf glbNormal <> "" Then
                    Code = "L"
                End If
                glbPNList(RowNo) = GenOp(2) & Code
            Else
                'we get here if Principle class method or call inserted in un-recognised
                'row position
                'or Cloisters.  In these cases do the call(s) from the indicated row
                'then call generaterows, which should be able to carry on from any
                'row by calculating the correct position in glbmethodpn array.
                'Find out how many separate genops are listed, i.e. how many commas
                'there are in CallGenOp.  Assume max 2 commas, i.e. three genops
                '(Scientific triples has 3,7,3 instead of 1,7,1 for instance)
                NoOfGenOps = 1
                For b = 1 To Len(CallGenOp)
                    If Mid$(CallGenOp, b, 1) = "," Then NoOfGenOps += 1
                Next

                If NoOfGenOps > 3 Then
                    ErrorLog("!!! Too many operations in call.")
                    Exit Sub
                End If

                Pos = 1
                For b = 1 To NoOfGenOps
                    GenOp(b) = ""
                    Do Until Mid$(CallGenOp, Pos, 1) = "," Or Pos > Len(CallGenOp)
                        GenOp(b) = GenOp(b) & Mid$(CallGenOp, Pos, 1)
                        Pos += 1
                    Loop
                    If glbNo_Of_Bells = LastPlace + 1 Then  'add tenor behind
                        GenOp(b) = GenOp(b) & UnBelvert(glbNo_Of_Bells)
                    End If
                    Pos += 1 'skip the ","
                Next
                RowNo = Row - 1
                'assume user clicked on first row affected by call
                For b = 1 To NoOfGenOps
                    glbRow = RowNo      'executePN requires glbrow is set up
                    ExecutePN(GenOp(b))

                    If glbBob <> "" Then
                        Code = "B"
                    ElseIf glbSingle <> "" Then
                        Code = "S"
                    ElseIf (glbNormal <> "") And
                      Not glbMethodName Like "Stedman" And
                      Not glbMethodName Like "Cloisters" And
                      Not glbMethodName Like "Erin" Then
                        Code = "L"
                        'not appropriate for Stedman, Erin or Cloisters since
                        'lead ends are distant from calling positions
                    End If
                    glbPNList(RowNo) = GenOp(b) & Code
                    RowNo += 1
                Next
                'done the call.
                'Now check to see if rounds has come up
                RowString = ""
                For b = 1 To glbNo_Of_Bells
                    RowString = RowString & glbRowsArray(RowNo, b)
                Next
                If RowString = Rounds Then
                    'call has brought about rounds so add some rounds to glbrowsarray
                    glbThatsAllRow = RowNo + 1
                    GenerateRounds(RowNo + 1, 60) 'glbrow gets updated by GenerateRounds
                    'and clear the rows array
                    ClearRAfrom(glbRow)
                    'and any dangling entries in glbpnlist
                    RowNo = glbRow - 1
                    Do Until glbPNList(RowNo) = ""
                        glbPNList(RowNo) = ""
                        RowNo = RowNo + 1
                    Loop
                    ReachedRounds = True
                Else
                    'Now work out where we are in the lead and do some more changes to
                    'reach the lead head if necessary
                    n = ((RowNo - glbStartRow + 1) Mod glbLL) + 1
                    If n = 1 Then
                        'we are at the lead head so done
                        RowNo -= 1 'to compensate for an increment later on
                    Else
                        Do Until glbMethodPN(n) = ""
                            CallGenOp = glbMethodPN(n)
                            glbRow = RowNo
                            ExecutePN(CallGenOp)
                            glbPNList(RowNo) = CallGenOp
                            RowString = ""
                            For b = 1 To glbNo_Of_Bells
                                RowString &= glbRowsArray(RowNo + 1, b)
                            Next
                            If RowString = Rounds Then 'reached rounds before lead end
                                'call has brought about rounds so add some rounds to glbrowsarray
                                glbThatsAllRow = RowNo + 1
                                GenerateRounds(RowNo + 1, 60)
                                'and clear the rows array
                                ClearRAfrom(glbRow)
                                'and any dangling entries in glbpnlist
                                RowNo = glbRow - 1
                                Do Until glbPNList(RowNo) = ""
                                    glbPNList(RowNo) = ""
                                    RowNo += 1
                                Loop
                                ReachedRounds = True
                                Exit Do
                            End If
                            n += 1
                            RowNo += 1
                        Loop
                        If Not ReachedRounds Then
                            'do the lead-end/lead-head change
                            glbRow = RowNo

                            If glbLHGenOp = "." Then
                                RowNo -= 1 'to compensate for the increment in the do loop
                                glbPNList(RowNo) = glbPNList(RowNo) & "L"
                                'do nothing for lead end
                            Else
                                ExecutePN(glbLHGenOp)
                                glbPNList(RowNo) = glbLHGenOp & "L"
                            End If
                        End If
                    End If
                End If
            End If
        End If

        RowNo += 1



        If Not invalidPN And Not ReachedRounds Then
            RowString = ""
            For b = 1 To glbNo_Of_Bells
                RowString &= glbRowsArray(RowNo, b)
            Next
            If RowString <> Rounds Then 'have not reached rounds
                glbThatsAllRow = 0  'plain lead may have brought up rounds, but call has
                'extended the touch
                GenerateRows(RowNo + 1, "")  'generate two more courses, no annotation
            Else
                'call has brought about rounds so add some rounds to glbrowsarray
                glbThatsAllRow = RowNo
                GenerateRounds(RowNo, 60)
                'and clear the rows array
                ClearRAfrom(glbRow)
                'and any dangling entries in glbpnlist
                RowNo = glbRow - 1
                Do Until glbPNList(RowNo) = ""
                    glbPNList(RowNo) = ""
                    RowNo += 1
                Loop
            End If
        End If


        glbStatsStartRow = 1
        'glbStatsEndRow = glbEndRow  'for benefit of calHG, called by glbanalyse
        'I think calcHG works out glbstatsendrow for itself,
        'except when called by mnuSJ - 25/10/19

        GlbAnalyse()
        Exit Sub

errorhandler:
        ErrorLog("!!! Error in Implement Call routine: " & Err.Number & ": " & Err.Description)


    End Sub

    Public Sub PrepGenerateRows(MethodName As String, IsOdd As Boolean)
        'gets things ready for generating rows in the glbRowsArray
        'Uses glbCCCBR_PN, i.e. place notation in CCCBR.txt format
        'Also creates glbLHGenOp from glbCCCBR_PN.
        'Also reads off lead length and generates glbLL for use by other routines.
        'Assumes number of bells ringing is glbNo_of_bells

        'generates global variables glbHLSym, glbLHGenOp, glbLL, glbMethodPN
        'i.e. place notation symmetry indicator, PN for lead head generation
        'lead length, and the PN for one lead of the method, excluding leadhead PN.
        'Also generates call options for the cmbBob, cmbSingle and cmbNormal combos
        'in the CallDialog form


        Dim m As Integer, n As Integer, i As Integer
        Dim Place As Integer
        Dim PlaceNotation As String
        Dim Character As Char

        On Error GoTo errorhandler


        'CCCBR.txt format includes leading and lying places, but not tenor behind

        For m = 1 To MethodPNLength_const 'MethodPNLength_const is a constant = 200
            glbMethodPN(m) = ""
        Next
        'glbLL = 0
        m = 1
        n = 1
        Do
            Do
                Character = Mid$(glbCCCBR_PN, m, 1)
                If Character = Chr(9) Then
                    'finished getting that PN but
                    'add tenor behind if necessary
                    If IsOdd Then 'add tenor behind
                        'assume all ringing takes place on an even number of bells
                        'i.e. doubles on 6, triples on 8 etc
                        glbMethodPN(n) = glbMethodPN(n) & UnBelvert(glbLastPlace + 1)
                    End If
                    n += 1
                    m += 1


                    Exit Do
                Else
                    glbMethodPN(n) = glbMethodPN(n) & Character
                    m += 1
                    If m > Len(glbCCCBR_PN) Then
                        'need to flesh out this last PN


                        If IsOdd Then 'add tenor behind
                            glbMethodPN(n) = glbMethodPN(n) & UnBelvert(glbLastPlace + 1)
                        End If
                        Exit Do
                    End If
                End If
            Loop
        Loop Until m > Len(glbCCCBR_PN)

        glbLHGenOp = glbMethodPN(n) 'CCCBR.txt file gives complete PN list, inc. LE-LH
        glbMethodPN(n) = ""
        glbHLSym = True
        'check to see if PN list is palindromic from start to finish - 1
        For i = 1 To (n - 1) \ 2
            If glbMethodPN(i) <> glbMethodPN(n - i) Then
                glbHLSym = False
                Exit For
            End If
        Next
        'These procedures may seem illogical but were devised to cope with microSiril
        'format method files, and results are still needed

        'set up possible calls

        If (glbLastPlace Mod 2 = 1) And (glbNo_Of_Bells Mod 2 = 0) Then
            'strip tenor behind part of .cmbNormal for odd-bell methods being rung
            'on an even number of bells
            PlaceNotation = Left(glbLHGenOp, Len(glbLHGenOp) - 1)
        Else
            PlaceNotation = glbLHGenOp
        End If
        glbNormal1 = PlaceNotation
        glbNormal2 = ""
        'default; special cases may alter this...

        If glbLastPlace Mod 2 = 0 Then  'even bell methods
            Select Case UCase$(MethodName)
                Case "DOUBLE NORWICH COURT BOB"  'did have Kent and Oxford in here,
                    'but Kent and Oxford have 4th place bobs
                    'Why does DNCBM have 6th?
                    glbBob1 = "1" & UnBelvert(glbLastPlace - 2)
                    glbBob2 = ""
                    glbSingle1 = "1" & UnBelvert(glbLastPlace - 2) &
                                        UnBelvert(glbLastPlace - 1) & UnBelvert(glbLastPlace)
                    glbSingle2 = ""
                Case Else

                    If glbHLSym Then  'so this is any even-bell method with palindromic PN
                        'including Glasgow, Cornwall, which may well have 6th
                        'place bobs, but cannot assume this.
                        glbBob1 = "14"  'Plain Bob major bob
                        glbBob2 = "1" & UnBelvert(glbLastPlace)   'for bringing round
                        'half-courses
                        glbSingle1 = "1234" 'Plain bob major single
                        glbSingle2 = ""
                    Else
                        glbBob1 = "3" & UnBelvert(glbLastPlace) & ",1" &
                                                         UnBelvert(glbLastPlace)
                        'Grandsire major bob
                        glbBob2 = ""
                        glbSingle1 = "3" & UnBelvert(glbLastPlace) &
                                                   ",123" & UnBelvert(glbLastPlace)
                        'grandsire major single
                        glbSingle2 = ""
                        glbNormal1 = UnBelvert(glbLastPlace - 1) &
                                UnBelvert(glbLastPlace) & ",1" & UnBelvert(glbLastPlace)
                    End If
            End Select
        Else    'odd bell methods

            If UCase$(MethodName) = "STEDMAN" Or
               UCase$(MethodName) = "ERIN" Or
               UCase$(MethodName) = "CLOISTERS" Then
                If glbLastPlace >= 7 Then      'Stedman or Erin or Cloisters above doubles
                    glbBob1 = UnBelvert(glbLastPlace - 2)
                    glbBob2 = ""
                    glbSingle1 = UnBelvert(glbLastPlace - 2) &
                                    UnBelvert(glbLastPlace - 1) & UnBelvert(glbLastPlace)
                    glbSingle2 = ""
                    glbNormal1 = UnBelvert(glbLastPlace)
                Else
                    'Stedman or Erin doubles
                    glbBob1 = ""
                    glbBob2 = ""
                    glbSingle1 = "145"
                    glbSingle2 = "345"
                    glbNormal1 = "1"
                    glbNormal2 = "3"
                End If
            ElseIf UCase$(MethodName) = "ORIGINAL" Then
                glbBob1 = "14" & UnBelvert(glbLastPlace)
                glbBob2 = ""
                glbSingle1 = "1234" & UnBelvert(glbLastPlace)
                glbSingle2 = ""
                glbNormal1 = "1"
                glbNormal2 = ""
            ElseIf glbHLSym Then
                glbBob1 = "14" & Mid$(glbLHGenOp, 3, 1) 'Plain Bob Triples,
                glbBob2 = ""
                If glbLastPlace > 5 Then _
                  glbSingle1 = "1234" & Mid$(glbLHGenOp, 3, 1) 'Middlesex etc
                glbSingle2 = ""
                'tenor behind gets added to LH gen op at some point later...
                'doesn't work for Bowerchalkeplace doubles!
                'nor Holyordersbob triples! 5/11/19
                'cmbNormal is set to glbLHgenOp above
            Else
                glbBob1 = "3,1"       'Grandsire triples etc
                glbBob2 = ""
                glbSingle1 = "3,123"
                glbSingle2 = ""
                PlaceNotation = glbMethodPN(glbLL - 1)
                PlaceNotation = Left(PlaceNotation, Len(PlaceNotation) - 1)
                glbNormal1 = PlaceNotation & ",1"
                glbNormal2 = ""
            End If
        End If

        Exit Sub

errorhandler:
        ErrorLog("!!! PrepGenerateRows Error: " & Err.Number & ": " & Err.Description)

    End Sub

    Public Sub ClearRAfrom(StartRow As Integer)
        'clears the glbRowsArray from the given row onwards.
        Dim b As Byte, Row As Integer
        Row = StartRow
        Do
            For b = 1 To No_Of_Bells_Const
                glbRowsArray(Row, b) = Chr(0)
            Next
            Row += 1
        Loop Until glbRowsArray(Row, 1) = Chr(0)
    End Sub

    Public Sub CmdDoneMethodChoose_Click()
        'a sub from Cirel.  Not really logical design for GetMethodAndTouch
        'but it works
        'Note that Diagrams is a boolean for Cirel to indicate user is just
        'looking up method
        Dim MethodName As String
        Dim R, b As Integer, n As Integer
        Dim NomTime As Long, interval As Integer
        Dim IsOdd As Boolean

        On Error GoTo errorhandler

        'If glbStartRounds Then
        glbStartChange = ""
        For n = 1 To glbNo_Of_Bells
            glbStartChange &= UnBelvert(n)
        Next
        'Else
        '  glbStartChange = TxtStartChange.Text
        'End If
        MethodName = glbMethodName
        Select Case glbLastPlace
            Case 3
                MethodName &= " Singles"
            Case 4
                MethodName &= " MInimus"
            Case 5
                MethodName &= " Doubles"
            Case 6
                MethodName &= " Minor"
            Case 7
                MethodName &= " Triples"
            Case 8
                MethodName &= " Major"
            Case 9
                MethodName &= " Caters"
            Case 10
                MethodName &= " Royal"
            Case 11
                MethodName &= " Cinques"
            Case 12
                MethodName &= " Maximus"
        End Select

        IsOdd = glbLastPlace Mod 2 = 1

        GetPlaceNotation(MethodName, Format(glbLastPlace))
        'look up PN from CCCBR library
        'and set up glbCCCBR_PN and
        'glbLeadHeadCode



        'Has this sub been invoked by a call to change the method. If so don't create
        'any rounds; just start the new method from the clicked row, otherwise
        'assume user is running a method check on a new cirel file

        If glbOther = "Change Method" Then
            'don't create any rounds
            'glbStartRow = glbStartRow + 1  'this line is commented out in Cirel
            'but start on the row after the one that was clicked
        Else
            '  If glbDiagrams Then
            '    glbEndRow = 3 'else generaterounds won't generate rounds
            '    GenerateRounds 0, 1
            '  Else
            GenerateRounds(1, glbStartRow - 1) 'create the initial rounds, update glbrow
            '  End If
        End If
        ClearRAfrom(glbRow)           'clear the rest of the rows array
        'glbrow is either set by the generaterounds sub
        'or by the mousedown event that initiated the call

        'glbLastPlace = Val(cmbNoOfChBells.Text)
        PrepGenerateRows(glbMethodName, IsOdd)   'interpret CCCBR place notation. etc

        GenerateRows(glbStartRow, "M")   'generate two courses of the method
        'and annotate PN to show start of changes




        GlbAnalyse()


        Exit Sub

errorhandler:
        If Err.Number = 53 Then
            ErrorLog("!!! CCCBR.txt file not found")
        Else
            ErrorLog("!!! Choose Method Error: " & Err.Number & ": " & Err.Description)
        End If

    End Sub

    Public Sub DetectMethod()
        'This routine works out where the changes start, whether
        'it's an odd-bell method and the lead length, based on distance between whole
        'pulls of the treble.  If the lead length seems to be rather long, then it
        'tries its luck with a 12-row lead (as for Stedman), then a 6-row (Erin) then
        '2-row (Original)***2-row leads no longer tested***
        'It then tries to work out what the method is, by grabbing a lead of place
        'notations and looking up the method in a z-file.
        'If the PN List ends with 14 or 1234 this is replaced with 12 so that the plain
        'lead is searched for.
        'There are z-files for each stage from minimus to max.  The methods are
        'arranged in ascending PN order to facilitate searching.
        'There is some error correction when grabbing the PN list; if a bell is found
        'to jump more than 1 place an adjustment is made.  This may not be the correct
        'adjustment!***no longer error correction, just error flagging***
        'Once the method is ascertained all relevant information is loaded into the
        'various controls in the frmeChooseMethod frame, and the cmdDoneMethodChoose
        '_Click procedure is called.
        'The DiscoverTouch sub can then be called (by main) which analyses
        'the striking lead by lead to detect calls.  Cirel attempts to work
        'out what the calls are and can successfully plough through quite choppy
        'ringing in a reasonably intelligent way!
        Dim PNList(MethodPNLength_const) As String, PN As String, PN2 As String
        Dim CallPN1 As String, CallPN2 As String, lclClass As String
        Dim lclStartRow As Integer
        Dim PNpos As Byte
        Dim info As GlbMethodRecord, Filenum As Long
        Dim Path2Z As String, Entry As String, CirelPNStr As String
        Dim IsOdd As Boolean



        On Error GoTo errorhandler

        If glbEndRow = 0 Then
            ErrorLog("!!! No data loaded")
            Exit Sub
        End If

        'RowSort   'row sort before trying to discover the method
        'Ian now tells me the .csv striking file is row-sorted

        DiscoverStartRow(1)
        If glbStartRow = 0 Then
            glbMethodName = "Unknown ringing on " & glbNo_Of_Bells
            glbMethodFound = False
            Exit Sub 'back to main()
        Else
            lclStartRow = glbStartRow
            'txtStartRow.Text = Format$(lclStartRow)
            If DiscoverOddMethod() Then
                glbLastPlace = glbNo_Of_Bells - 1
            Else
                glbLastPlace = glbNo_Of_Bells
            End If
            'cmbNoOfChBells.Text = Format$(no_of_bells_ch)
            glbLL = DiscoverLL(lclStartRow, glbLastPlace)
            If glbLL = 0 Then
                'might be a principle
                glbLL = 12
                'Exit Sub
            End If
        End If


        ' Ian will ensure all complete rows, and last row is backstroke

        '***comment out one of these lines depending on whether running from IDE or command line
#If runfromcommandline Then
        
        Path2Z = Environment.CurrentDirectory & "\CCCBR_lib\z" & Format$(glbLastPlace) & ".cdb"
#Else
        Path2Z = "C:\Users\Martin\Documents\VS2019\CCCBR_lib\z" & Format$(glbLastPlace) & ".cdb"
#End If

        Filenum = FreeFile()
        FileOpen(Filenum, Path2Z, OpenMode.Input)
        glbMethodFound = False
        lclStartRow -= glbLL
        'to compensate first time for glbll increment
        Do
            lclStartRow += glbLL
            If lclStartRow - 1 + glbLL > glbEndRow Then Exit Do

            'grab a lead of PN's into glbMethodPN array, including lead end

            If DiscoverPNList(lclStartRow, glbLL) Then

                'if the last PN is "14" or "1234" change to "12" before looking up the method
                '(if last PN is Bob or Single change to plain lead...)
                'If glbMethodPN(glbLL) = "14" Or glbMethodPN(glbLL) = "1234" Then _
                '  glbMethodPN(glbLL) = "12"
                'If glbMethodPN(glbLL) = "14" & glbLastPlace & glbNo_Of_Bells Or _
                '  glbMethodPN(glbLL) = "1234" & glbLastPlace & glbNo_Of_Bells Then _
                '  glbMethodPN(glbLL) = "12" & glbLastPlace & glbNo_Of_Bells
                '***This is not a good idea because some methods are nothing like others,
                'but still have 14 or 1234 LE
                'e.g. St Mary Bourne Bob Minor, Waterloo Reverse Bob Major, Oxford Surprise Major
                'Modify the z-files instead, using the Formatter program.
                '...and look up method
                If DiscoverMethod(glbLL, Filenum) Then
                    glbMethodFound = True
                    'but check its not one of these variations on Grandsire Triples...
                    '(Grandsire with bobs; Grandsire with singles)
                    'Should I tweak the z-files to deal with these cases?
                    'Might have to do so manually...
                    'Still need...
                    If glbMethodName = "St Augustine Bob" Then
                        glbMethodName = "Grandsire"
                        'assume band is ringing bob course of Grandsire rather than
                        'St Augustine (Triples)
                    End If
                    If glbMethodName = "Newbury Old Bob" Then
                        glbMethodName = "Grandsire"
                        'assume band is ringing bob course of Grandsire rather than
                        'Newbury Old Bob (Doubles)
                        'Thanks Ben (Waller)!
                    End If

                    Exit Do
                End If
            End If

            FileClose(Filenum) 'start again for next lead
            FileOpen(Filenum, Path2Z, OpenMode.Input)
        Loop
        FileClose(Filenum)

        If Not glbMethodFound Then
            'perhaps a Grandsire type bob course,
            'so look for method pn that matches something in
            'z file up to but excluding lead end
            '(actually two rows shorter for methods like Grandsire)
            FileOpen(Filenum, Path2Z, OpenMode.Input)
            lclStartRow = glbStartRow - glbLL
            Do
                lclStartRow += glbLL
                If lclStartRow - 1 + glbLL > glbEndRow Then Exit Do

                're-grab a lead of PN's into glbMethodPN array, including lead end
                If DiscoverPNList(lclStartRow, glbLL) Then

                    '...and look up method, based on ringing, excluding lead end
                    If DiscoverMethod(glbLL - 2, Filenum) Then
                        'found a match in the z file for the first n-2 rows of a lead, but
                        'neeed to check last two PN's are either the bob or single for the
                        'method found
                        glbMethodFound = True
                        'PN = glbMethodPN(glbLL - 1) 'these are the last two pns as grabbed
                        'PN2 = glbMethodPN(glbLL)
                        'GetPlaceNotation(glbMethodName, Format(glbLastPlace))
                        'IsOdd = glbLastPlace Mod 2 = 1
                        'PrepGenerateRows(glbMethodName, IsOdd) 'set up calls for guessed-at method
                        '(and loads glbMethodPN with
                        ' actual method PN list)
                        'CallPN1 = glbBob1
                        'CallPN2 = glbSingle1
                        'If InStr(CallPN1, ",") = 0 And InStr(CallPN2, ",") = 0 Then
                        'just one LE PN
                        'If (glbLastPlace Mod 2 = 1) And (glbNo_Of_Bells = glbLastPlace + 1) Then
                        'delete the tenor behing part of the PN
                        'PN2 = Left(PN2, Len(PN2) - 1)
                        'End If
                        'if last but one pn as grabbed <> last but one pn in method
                        'then method not the right one
                        'If PN <> glbMethodPN(glbLL - 1) Then glbMethodFound = False
                        'if last pn as grabbed <> bob or single then method not the right one
                        'If Not ((PN2 = CallPN1) Or (PN2 = CallPN2)) Then glbMethodFound = False
                        'Else
                        'calls comprise two pn's
                        'If (glbLastPlace Mod 2 = 1) And (glbNo_Of_Bells = glbLastPlace + 1) Then
                        'delete the tenor behing part of the PN's
                        'PN = Left(PN, Len(PN) - 1)
                        'PN2 = Left(PN2, Len(PN2) - 1)
                        'End If
                        'PN = PN & "," & PN2
                        'If Not ((PN = CallPN1) Or (PN = CallPN2)) Then glbMethodFound = False
                        'End If

                        If glbMethodName = "St Augustine Bob" Or
                           glbMethodName = "Union" Then
                            glbMethodName = "Grandsire"
                        End If
                        'assume band is ringing bob course of Grandsire rather than
                        'St Augustine (Triples) or Union
                        If glbMethodFound Then
                            Exit Do
                        End If
                    End If
                End If

                FileClose(Filenum) 'start again for next lead
                FileOpen(Filenum, Path2Z, OpenMode.Input)
            Loop

            FileClose(Filenum)
        End If

        If Not glbMethodFound Then
            'might be a 12-row principle, such as Stedman
            glbLL = 12
            lclStartRow = glbStartRow - glbLL
            FileOpen(Filenum, Path2Z, OpenMode.Input)
            Do
                lclStartRow += glbLL
                If lclStartRow - 1 + glbLL > glbEndRow Then Exit Do
                If DiscoverPNList(lclStartRow, glbLL) Then
                    If DiscoverMethod(glbLL, Filenum) Then
                        glbMethodFound = True
                        Exit Do
                    End If
                End If
                FileClose(Filenum) 'start again for next lead
                FileOpen(Filenum, Path2Z, OpenMode.Input)
            Loop
            FileClose(Filenum)
        End If

        If Not glbMethodFound Then
            'might be a 6-row principle, such as Erin
            glbLL = 6
            lclStartRow = glbStartRow - glbLL
            FileOpen(Filenum, Path2Z, OpenMode.Input)
            Do
                lclStartRow += glbLL
                If lclStartRow - 1 + glbLL > glbEndRow Then Exit Do
                If DiscoverPNList(lclStartRow, glbLL) Then

                    If DiscoverMethod(glbLL, Filenum) Then
                        glbMethodFound = True
                        Exit Do
                    End If
                End If
                FileClose(Filenum)
                FileOpen(Filenum, Path2Z, OpenMode.Input)
            Loop
            FileClose(Filenum)
        End If

        'If Not glbMethodFound Then
        'might be a 2-row principle, i.e. Original
        'glbLL = 2
        'lclStartRow = glbStartRow - glbLL
        'FileOpen(Filenum, Path2Z, OpenMode.Input)
        'Do
        'lclStartRow += glbLL
        'If lclStartRow - 1 + glbLL > glbEndRow Then Exit Do
        'If DiscoverPNList(lclStartRow, glbLL) Then
        'If DiscoverMethod(glbLL, Filenum) Then
        'glbMethodFound = True
        'Exit Do
        'End If
        'End If
        'FileClose(Filenum)
        'FileOpen(Filenum, Path2Z, OpenMode.Input)
        'Loop
        'FileClose(Filenum)
        'End If

        If glbMethodFound Then
            glbStartInRounds = True
            CmdDoneMethodChoose_Click()
            'this will set up calls, among other operations, so call type can now be
            'relied upon, i.e. single (like Plain Bob) or double (like Grandsire) element
        Else
            glbMethodName = "Unrecognised"
            glbTouchScript = "Call, Row" & vbCrLf & "M," & glbStartRow - 1
        End If

        'list the stage names for the benefit of glbTouchScript entry of method name
        Select Case glbLastPlace
            Case 3
                glbStage = "Singles"
            Case 4
                glbStage = "Minimus"
            Case "5"
                glbStage = "Doubles"
            Case "6"
                glbStage = "Minor"
            Case "7"
                glbStage = "Triples"
            Case "8"
                glbStage = "Major"
            Case "9"
                glbStage = "Caters"
            Case "10"
                glbStage = "Royal"
            Case 11
                glbStage = "Cinques"
            Case 12
                glbStage = "Maximus"
        End Select


        Exit Sub

errorhandler:
        ErrorLog("!!! Error in DetectMethod " & Err.Number & ": " & Err.Description)

    End Sub

    Private Function DiscoverMethod(ByVal CheckLength As Integer, Filenum As Long) As Boolean
        'looks through given (open) z-file looking for glbMethodPN
        'checking over CheckLength entries.  Returns True if PN is found.
        Dim i As Integer, j As Integer, k As Integer
        Dim PNpos As Byte, info As GlbMethodRecord
        Dim Entry As String, CirelPNStr As String
        glbMethodFound = False

        ReDim info.PNList(200)
        info.Name = ""  'don't think this is needed, but keeps VS happy

        Do Until EOF(Filenum)
            'Line Input #Filenum, Entry  'get next entry in z file
            Entry = LineInput(Filenum)
            i = InStr(Entry, ":")
            CirelPNStr = Left$(Entry, i - 1)
            info.Name = Right$(Entry, Len(Entry) - i)
            i = 1
            k = 1
            Do Until InStr(i, CirelPNStr, " ") = 0  'until no more spaces,
                'i.e. last but one entry
                j = InStr(i, CirelPNStr, " ")
                info.PNList(k) = Mid$(CirelPNStr, i, j - i)
                i = j + 1
                k += 1
            Loop
            If k <> glbLL Then
                'no of entries in PN list is wrong so don't bother to check contents
            Else
                info.PNList(k) = Right$(CirelPNStr, Len(CirelPNStr) - i + 1)
                'get the last PN in the string
                If k > CheckLength Then 'remove unwanted entries in info.pnlist
                    Do Until k = CheckLength
                        info.PNList(k) = ""
                        k -= 1
                    Loop
                End If
                PNpos = 1
                Do
                    If info.PNList(PNpos) > glbMethodPN(PNpos) Then
                        'gone past possible match in z file
                        DiscoverMethod = False
                        Exit Function
                    End If
                    If info.PNList(PNpos) = glbMethodPN(PNpos) Then
                        'go to next PN in list
                        PNpos += 1
                    Else
                        Exit Do
                        'pn lists don't match - try next record in z file
                    End If
                    If PNpos > CheckLength Then
                        'found match
                        glbMethodFound = True
                        Exit Do
                    End If
                Loop
                If glbMethodFound Then Exit Do
            End If
        Loop
        If glbMethodFound Then
            DiscoverMethod = True
            'need to strip off the stage part of the method name since next procedure
            'adds it back on
            i = InStrRev(info.Name, " ")
            info.Name = Left(info.Name, i - 1)
            glbMethodName = info.Name
        Else
            DiscoverMethod = False
        End If

    End Function

    Private Function DiscoverOddMethod() As Boolean
        'looks at first 8 rows after glbStartRow; if at least 6 rows are generated
        'by a PN whose right-most value = glbno_of_bells then odd
        'Assumes even number of bells are ringing.
        Dim Count As Byte, i As Byte
        DiscoverOddMethod = False

        If glbEndRow < glbStartRow + 8 Then Exit Function

        DiscoverPNList(glbStartRow, 8)
        Count = 0
        For i = 1 To 8
            If Right$(glbMethodPN(i), 1) = UnBelvert(glbNo_Of_Bells) Then Count += 1
        Next
        If Count > 5 Then DiscoverOddMethod = True
    End Function

    Private Function DiscoverPN(Row As Integer) As String
        'returns the place notation that has generated this row in glbdata
        'from the previous one, e.g. "16", "-". ("-" signifies all bells swap)
        'If any bell has moved more than one position returns "?"

        Dim i As Integer
        Dim PN As String
        Dim RowErrors() As RowError

        ReDim RowErrors(glbNo_Of_Bells)  'all entries should be 0

        PN = ""
        For i = 1 To glbNo_Of_Bells
            If glbData(Row, i).bellch = glbData(Row - 1, i).bellch Then
                If UnBelvert(i) = "O" Then
                    PN &= "0"
                Else
                    PN &= UnBelvert(i)
                End If
            End If
        Next

        If glbNo_Of_Bells Mod 2 = Len(PN) Mod 2 Then
            'OK
        Else
            'a bell must have jumped more than 1 place
            PN = "?"
        End If

        If PN = "" Then PN = "-" 'cross
        DiscoverPN = PN
    End Function

    Private Function DiscoverPNList(StartRow As Integer, n As Integer) As Boolean
        'grab the first n place notations into glbmethodPN array
        'returns True if all PN's look OK, but False if any bell is seen to jump
        'more than one position in the any of the n PN's examined
        Dim i As Integer

        DiscoverPNList = True

        'first clear the array
        For i = 1 To MethodPNLength_const
            glbMethodPN(i) = ""
        Next
        'now grab the pn's
        For i = 1 To n
            glbMethodPN(i) = DiscoverPN(StartRow + i - 1)
            If glbMethodPN(i) = "?" Then
                DiscoverPNList = False
                'don't exit for benefit of DiscoverOddMethod sub
            End If
        Next
    End Function

    Private Sub DiscoverStartRow(FromRow As Integer)
        'pn for initial rounds is, e.g. 123456, i.e. places made in all 6 places
        'method start PN could be 3456, but so could a wobble at lead, so check for
        'PN with <= 4 places on three consectutive occasions to be more certain of
        'start row. Thus 213456 followed by 123456 is not start of method.
        Dim Row As Integer

        If FromRow Mod 2 = 1 Then Row = FromRow Else Row = FromRow - 1

        Do
            Row += 2
            glbMethodPN(1) = DiscoverPN(Row)
            glbMethodPN(2) = DiscoverPN(Row + 1)
            glbMethodPN(3) = DiscoverPN(Row + 2)
            If Row > glbEndRow Then
                Row = 0
                Exit Do
            End If
        Loop Until (Len(glbMethodPN(1)) <= 4) And
                   (Len(glbMethodPN(2)) <= 4) And
                   (Len(glbMethodPN(3)) <= 4)

        glbStartRow = Row

    End Sub

    Public Sub OpenHawkearCSV(FileName As String)
        'This facility reads a comma-separated variables file, Hawkear format.
        'A hawkear .csv file is arranged as lines, i.e. bell, comma, time(ms), CRLF.
        'Actually, there may be more data on each line, viz times when the bell
        'should have rung, according to various models
        'First line is a header.  Bell is "1", "2",..."10", "11", "12"
        'Algorithm discards first line, then reads bell, time into glbData array
        'glbno_of_bells variable is also calculated automatically.


        Dim info As String, strPath As String
        Dim n As Integer, Filenum As Integer
        Dim Row As Integer
        Dim b As Byte, S As Byte, f As Byte

        On Error GoTo errorhandler
        Filenum = FreeFile()

        strPath = FileName
        ClearData()
        glbNo_of_Bell_Events = 0

        FileOpen(Filenum, strPath, OpenMode.Input)

        info = LineInput(Filenum)
        'discard first line

        'now collect data from first 15 dings and work out how many bells are ringing
        glbNo_Of_Bells = 1
        For b = 1 To 15
            info = LineInput(Filenum)
            f = InStr(info, ",")
            n = Val(Left$(info, f - 1))
            If n > glbNo_Of_Bells Then glbNo_Of_Bells = n
        Next b

        If glbNo_Of_Bells > 12 Then
            ErrorLog("!!! Too many bells! Can only deal with 4 to 12")
            Exit Sub
        ElseIf glbNo_Of_Bells < 4 Then
            ErrorLog("!!! Too few bells! Can only deal with 4 to 12")
            Exit Sub
        End If

        'now close and re-open the file and collect the data into glbdata array
        FileClose(Filenum)
        FileOpen(Filenum, strPath, OpenMode.Input)

        info = LineInput(Filenum)  'discard first line again

        Row = 1

        Do Until EOF(Filenum)
            b = 1
            Do Until b > glbNo_Of_Bells
                info = LineInput(Filenum)
                f = InStr(info, ",")
                glbData(Row, b).bellch = UnBelvert(Val(Left$(info, f - 1)))
                S = InStr(f + 1, info, ",")
                If S = 0 Then
                    'read off the rest of the line
                    S = Len(info)
                    glbData(Row, b).Time = Val(Right$(info, S - f))
                Else
                    glbData(Row, b).Time = Val(Mid$(info, f + 1, S - f))
                End If
                b += 1
                glbNo_of_Bell_Events += 1
            Loop
            Row += 1
        Loop
        Row -= 1
        FileClose(Filenum)

        glbEndRow = Row

        Exit Sub

errorhandler:
        If Err.Number = 5 Then
            ErrorLog("!!! Error reading Hawkear CSV File: Incorrect format (Attempt to read beyound EOF)")
            Exit Sub
        Else
            ErrorLog("!!! Open Hawkear CSV file Error: " & Err.Number & ": " & Err.Description)
        End If

    End Sub
    Private Sub OpenCirelFile(Filename As String)
        'Not relevant except when testing out Cirel ringing data files.
        'Opens the file passed to the sub as Filename
        'and the contents read into glbData array and glbno_of_bells variable

        Dim RecNum As Long     'Needed to access records within the files
        Dim ByteArray(4) As Byte
        Dim IntByte1, IntByte2, IntByte3 As Int32
        Dim row_no As Integer
        Dim b As Byte, Rollover As Byte
        Dim Temp As Object         'for rogue data from non-cirel file
        Dim Time1 As Long, Time2 As Long
        Dim NomTime As Long, interval As Integer
        Dim Filenum As Integer

        On Error GoTo errorhandler



        Filenum = FreeFile()           'Find next available file number


        FileOpen(Filenum, Filename, OpenMode.Random, RecordLength:=5)

        RecNum = 1
        FileGet(Filenum, ByteArray, RecNum)     'get first record from file, i.e. number of bells

        Temp = ByteArray(1)
        'Temp = b


        glbNo_Of_Bells = Temp
        RecNum = 2
        FileGet(Filenum, ByteArray, RecNum)

        Time1 = 0
        Rollover = 0
        row_no = 1

        ClearData()   'clear the global data array, ready to fill up with data recalled from disk

        glbNo_of_Bell_Events = 0

        Do
            For b = 1 To glbNo_Of_Bells
                FileGet(Filenum, ByteArray, RecNum)

                IntByte1 = ByteArray(2)
                IntByte2 = ByteArray(3)
                IntByte3 = ByteArray(4)

                If ByteArray(0) = 0 Then
                    'ignore: null entries may be introduced if bell sensor problems
                    b -= 1
                Else
                    IntByte1 <<= 8
                    IntByte2 <<= 16
                    IntByte3 <<= 24
                    Time2 = ByteArray(1) + IntByte1 + IntByte2 + IntByte3
                    If Time1 - Time2 > 16770000 And Time1 > 16770000 Then
                        Rollover = 1
                    End If
                    '24-bit time has rolled over, so add 2^24 on all subsequent reads
                    'It is possible that time1 is a little bit > time2 if bad leading
                    'If using a Cirel interface box and timings are generated in the box,
                    'roll-over will occur 4 hours, 39 minutes, 37.216 seconds after
                    'starting the Cirel software, or re-initialising the interface box.
                    'If using Windows to tell the time, a similar situation will occur
                    'since the last 3 bytes of the 4-byte long still roll over at the
                    'same rate.  When this will happen does not depend on when Cirel was
                    'started,however, so could be just after pulling off!

                    glbData(row_no, b).Time = Time2 + Rollover * &H1000000
                    '&H1000000 = 16777216
                    glbData(row_no, b).bellch = Chr(ByteArray(0))
                    Time1 = Time2
                    glbNo_of_Bell_Events += 1
                End If
                RecNum += 1
                If EOF(Filenum) Then Exit Do
            Next b

            row_no += 1
        Loop

        If b = 1 Then row_no -= 1
        glbEndRow = row_no
        glbStatsStartRow = 1

        FileClose(Filenum)                'Close the disk file

        Exit Sub

errorhandler:

        ErrorLog("!!! Open .crl file Error: " & Err.Description)

    End Sub
End Module

